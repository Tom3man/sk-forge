import pandas as pd
from prophet import Prophet
from sklearn.base import BaseEstimator, TransformerMixin


class ProphetFeatureGenerator(BaseEstimator, TransformerMixin):
    """
    Transformer that adds features generated by Facebook Prophet to an input Pandas DataFrame.
    This transformer assumes there is both a self.date_col and self.time_col column.
    """

    def __init__(self, y_col='close'):
        self.y_col = y_col

    def fit(self, X, y=None):
        return self

    def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:

        # Combine self.date_col and self.time_col columns into a single 'Datetime' column
        X['Datetime'] = pd.to_datetime(X[self.date_col] + ' ' + X[self.time_col])

        # Select the relevant columns for Prophet
        df_prophet = X[['Datetime', self.y_col]]

        # Rename columns to match Prophet's expected format
        df_prophet = df_prophet.rename(columns={'Datetime': 'ds', self.y_col: 'y'})

        # Initialize and fit Prophet model with desired seasonality components
        model = Prophet(seasonality_mode='additive', yearly_seasonality=True, weekly_seasonality=True)
        model.fit(df_prophet)

        # Generate future dates for predictions (periods=0 for current dates)
        future = model.make_future_dataframe(periods=0)

        # Make predictions
        forecast = model.predict(future)

        # Rename columns for consistency
        forecast = forecast.rename(columns={'ds': 'Datetime'})

        # Drop unnecessary columns
        columns_to_drop = [
            'yhat'
        ]
        forecast.drop(columns=columns_to_drop, inplace=True)

        # Rename columns with a prefix (e.g., 'FBP_')
        forecast = forecast.rename(
            columns={col: f'FBP_{col.upper()}' for col in forecast.columns if col != 'Datetime'}
        )

        # Merge the forecasted features with the original DataFrame using a left join
        X = X.merge(forecast, on='Datetime', how='left')

        # Drop the created datetime column
        X.drop(columns=['Datetime'], inplace=True)

        return X


class DateTimeEncoder(BaseEstimator, TransformerMixin):
    """
    Transformer that encodes date and time columns into separate components and adds them as features.
    This transformer assumes there is a self.date_col column.
    """

    def __init__(self, date_col: str, time_col: str):
        self.date_col = date_col
        self.time_col = time_col

    def fit(self, X, y=None):
        return self

    def transform(self, X: pd.DataFrame, y=None) -> pd.DataFrame:
        # Check if self.date_col column is not in datetime format and convert it if needed
        if not pd.api.types.is_datetime64_any_dtype(X[self.date_col]):
            X[self.date_col] = pd.to_datetime(X[self.date_col], errors='coerce')

        # Check if self.time_col column exists and is not in datetime format; convert it if needed
        if self.time_col in X.columns and not pd.api.types.is_datetime64_any_dtype(X[self.time_col]):
            X[self.time_col] = pd.to_datetime(X[self.time_col], errors='coerce')

        # Extract date components
        X['YEAR'] = X[self.date_col].dt.year
        X['MONTH'] = X[self.date_col].dt.month
        X['DAY'] = X[self.date_col].dt.day
        X['DAY_OF_WEEK'] = X[self.date_col].dt.dayofweek

        # Extract time components if self.time_col column exists
        if self.time_col in X.columns:
            X['HOUR'] = X[self.time_col].dt.hour
            X['MINUTE'] = X[self.time_col].dt.minute

        return X
